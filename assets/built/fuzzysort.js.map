{"version":3,"sources":["fuzzysort.js"],"names":["root","UMD","define","amd","module","exports","fuzzysort","this","isNode","require","window","preparedCache","Map","preparedSearchCache","noResults","total","matchesSimple","matchesStrict","cleanup","clear","defaultScoreFn","a","max","i","length","result","score","getValue","obj","prop","tmp","undefined","segs","Array","isArray","split","len","isObj","x","fastpriorityqueue","r","o","e","n","c","f","add","poll","peek","replaceTop","q","fuzzysortNew","instanceOptions","single","search","target","options","getPreparedSearch","getPrepared","allowTypo","algorithm","algorithmNoTypo","go","targets","searchLowerCode","prepareSearch","threshold","limit","resultsLen","limitedCount","targetsLen","keys","scoreFn","keysLen","objResults","keyI","key","_targetLowerCodes","_nextBeginningIndexes","indexes","results","goAsync","canceled","p","Promise","resolve","reject","iCurrent","step","startMs","Date","now","setImmediate","setTimeout","cancel","highlight","hOpen","hClose","highlighted","matchesIndex","opened","targetLen","matchesBest","char","substr","prepare","prepareLowerCodes","prepareSlow","prepareNextBeginningIndexes","targetPrepared","get","set","searchPrepared","searchLowerCodes","prepared","targetLowerCodes","searchLen","searchI","targetI","typoSimpleI","matchesSimpleLen","typoStrictI","successStrict","matchesStrictLen","nextBeginningIndexes","firstPossibleI","matchesBestLen","lastTargetI","str","strLen","lowerCodes","lower","toLowerCase","charCodeAt","prepareBeginningIndexes","beginningIndexes","beginningIndexesLen","wasUpper","wasAlphanum","targetCode","isUpper","isAlphanum","isBeginning","lastIsBeginning","lastIsBeginningI","new"],"mappings":"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","file":"fuzzysort.js","sourcesContent":["/*\nWHAT: SublimeText-like Fuzzy Search\n\nUSAGE:\n  fuzzysort.single('fs', 'Fuzzy Search') // {score: -16}\n  fuzzysort.single('test', 'test') // {score: 0}\n  fuzzysort.single('doesnt exist', 'target') // null\n\n  fuzzysort.go('mr', ['Monitor.cpp', 'MeshRenderer.cpp'])\n  // [{score: -18, target: \"MeshRenderer.cpp\"}, {score: -6009, target: \"Monitor.cpp\"}]\n\n  fuzzysort.highlight(fuzzysort.single('fs', 'Fuzzy Search'), '<b>', '</b>')\n  // <b>F</b>uzzy <b>S</b>earch\n*/\n\n// UMD (Universal Module Definition) for fuzzysort\n;(function(root, UMD) {\n  if(typeof define === 'function' && define.amd) define([], UMD)\n  else if(typeof module === 'object' && module.exports) module.exports = UMD()\n  else root.fuzzysort = UMD()\n})(this, function UMD() { function fuzzysortNew(instanceOptions) {\n\n  var fuzzysort = {\n\n    single: function(search, target, options) {\n      if(!search) return null\n      if(!isObj(search)) search = fuzzysort.getPreparedSearch(search)\n\n      if(!target) return null\n      if(!isObj(target)) target = fuzzysort.getPrepared(target)\n\n      var allowTypo = options && options.allowTypo!==undefined ? options.allowTypo\n        : instanceOptions && instanceOptions.allowTypo!==undefined ? instanceOptions.allowTypo\n        : true\n      var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo\n      return algorithm(search, target, search[0])\n      // var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991\n      // var result = algorithm(search, target, search[0])\n      // if(result === null) return null\n      // if(result.score < threshold) return null\n      // return result\n    },\n\n    go: function(search, targets, options) {\n      if(!search) return noResults\n      search = fuzzysort.prepareSearch(search)\n      var searchLowerCode = search[0]\n\n      var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991\n      var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991\n      var allowTypo = options && options.allowTypo!==undefined ? options.allowTypo\n        : instanceOptions && instanceOptions.allowTypo!==undefined ? instanceOptions.allowTypo\n        : true\n      var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo\n      var resultsLen = 0; var limitedCount = 0\n      var targetsLen = targets.length\n\n      // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\n\n      // options.keys\n      if(options && options.keys) {\n        var scoreFn = options.scoreFn || defaultScoreFn\n        var keys = options.keys\n        var keysLen = keys.length\n        for(var i = targetsLen - 1; i >= 0; --i) { var obj = targets[i]\n          var objResults = new Array(keysLen)\n          for (var keyI = keysLen - 1; keyI >= 0; --keyI) {\n            var key = keys[keyI]\n            var target = getValue(obj, key)\n            if(!target) { objResults[keyI] = null; continue }\n            if(!isObj(target)) target = fuzzysort.getPrepared(target)\n\n            objResults[keyI] = algorithm(search, target, searchLowerCode)\n          }\n          objResults.obj = obj // before scoreFn so scoreFn can use it\n          var score = scoreFn(objResults)\n          if(score === null) continue\n          if(score < threshold) continue\n          objResults.score = score\n          if(resultsLen < limit) { q.add(objResults); ++resultsLen }\n          else {\n            ++limitedCount\n            if(score > q.peek().score) q.replaceTop(objResults)\n          }\n        }\n\n      // options.key\n      } else if(options && options.key) {\n        var key = options.key\n        for(var i = targetsLen - 1; i >= 0; --i) { var obj = targets[i]\n          var target = getValue(obj, key)\n          if(!target) continue\n          if(!isObj(target)) target = fuzzysort.getPrepared(target)\n\n          var result = algorithm(search, target, searchLowerCode)\n          if(result === null) continue\n          if(result.score < threshold) continue\n\n          // have to clone result so duplicate targets from different obj can each reference the correct obj\n          result = {target:result.target, _targetLowerCodes:null, _nextBeginningIndexes:null, score:result.score, indexes:result.indexes, obj:obj} // hidden\n\n          if(resultsLen < limit) { q.add(result); ++resultsLen }\n          else {\n            ++limitedCount\n            if(result.score > q.peek().score) q.replaceTop(result)\n          }\n        }\n\n      // no keys\n      } else {\n        for(var i = targetsLen - 1; i >= 0; --i) { var target = targets[i]\n          if(!target) continue\n          if(!isObj(target)) target = fuzzysort.getPrepared(target)\n\n          var result = algorithm(search, target, searchLowerCode)\n          if(result === null) continue\n          if(result.score < threshold) continue\n          if(resultsLen < limit) { q.add(result); ++resultsLen }\n          else {\n            ++limitedCount\n            if(result.score > q.peek().score) q.replaceTop(result)\n          }\n        }\n      }\n\n      if(resultsLen === 0) return noResults\n      var results = new Array(resultsLen)\n      for(var i = resultsLen - 1; i >= 0; --i) results[i] = q.poll()\n      results.total = resultsLen + limitedCount\n      return results\n    },\n\n    goAsync: function(search, targets, options) {\n      var canceled = false\n      var p = new Promise(function(resolve, reject) {\n        if(!search) return resolve(noResults)\n        search = fuzzysort.prepareSearch(search)\n        var searchLowerCode = search[0]\n\n        var q = fastpriorityqueue()\n        var iCurrent = targets.length - 1\n        var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991\n        var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991\n        var allowTypo = options && options.allowTypo!==undefined ? options.allowTypo\n          : instanceOptions && instanceOptions.allowTypo!==undefined ? instanceOptions.allowTypo\n          : true\n        var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo\n        var resultsLen = 0; var limitedCount = 0\n        function step() {\n          if(canceled) return reject('canceled')\n\n          var startMs = Date.now()\n\n          // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\n\n          // options.keys\n          if(options && options.keys) {\n            var scoreFn = options.scoreFn || defaultScoreFn\n            var keys = options.keys\n            var keysLen = keys.length\n            for(; iCurrent >= 0; --iCurrent) { var obj = targets[iCurrent]\n              var objResults = new Array(keysLen)\n              for (var keyI = keysLen - 1; keyI >= 0; --keyI) {\n                var key = keys[keyI]\n                var target = getValue(obj, key)\n                if(!target) { objResults[keyI] = null; continue }\n                if(!isObj(target)) target = fuzzysort.getPrepared(target)\n\n                objResults[keyI] = algorithm(search, target, searchLowerCode)\n              }\n              objResults.obj = obj // before scoreFn so scoreFn can use it\n              var score = scoreFn(objResults)\n              if(score === null) continue\n              if(score < threshold) continue\n              objResults.score = score\n              if(resultsLen < limit) { q.add(objResults); ++resultsLen }\n              else {\n                ++limitedCount\n                if(score > q.peek().score) q.replaceTop(objResults)\n              }\n\n              if(iCurrent%1000/*itemsPerCheck*/ === 0) {\n                if(Date.now() - startMs >= 10/*asyncInterval*/) {\n                  isNode?setImmediate(step):setTimeout(step)\n                  return\n                }\n              }\n            }\n\n          // options.key\n          } else if(options && options.key) {\n            var key = options.key\n            for(; iCurrent >= 0; --iCurrent) { var obj = targets[iCurrent]\n              var target = getValue(obj, key)\n              if(!target) continue\n              if(!isObj(target)) target = fuzzysort.getPrepared(target)\n\n              var result = algorithm(search, target, searchLowerCode)\n              if(result === null) continue\n              if(result.score < threshold) continue\n\n              // have to clone result so duplicate targets from different obj can each reference the correct obj\n              result = {target:result.target, _targetLowerCodes:null, _nextBeginningIndexes:null, score:result.score, indexes:result.indexes, obj:obj} // hidden\n\n              if(resultsLen < limit) { q.add(result); ++resultsLen }\n              else {\n                ++limitedCount\n                if(result.score > q.peek().score) q.replaceTop(result)\n              }\n\n              if(iCurrent%1000/*itemsPerCheck*/ === 0) {\n                if(Date.now() - startMs >= 10/*asyncInterval*/) {\n                  isNode?setImmediate(step):setTimeout(step)\n                  return\n                }\n              }\n            }\n\n          // no keys\n          } else {\n            for(; iCurrent >= 0; --iCurrent) { var target = targets[iCurrent]\n              if(!target) continue\n              if(!isObj(target)) target = fuzzysort.getPrepared(target)\n\n              var result = algorithm(search, target, searchLowerCode)\n              if(result === null) continue\n              if(result.score < threshold) continue\n              if(resultsLen < limit) { q.add(result); ++resultsLen }\n              else {\n                ++limitedCount\n                if(result.score > q.peek().score) q.replaceTop(result)\n              }\n\n              if(iCurrent%1000/*itemsPerCheck*/ === 0) {\n                if(Date.now() - startMs >= 10/*asyncInterval*/) {\n                  isNode?setImmediate(step):setTimeout(step)\n                  return\n                }\n              }\n            }\n          }\n\n          if(resultsLen === 0) return resolve(noResults)\n          var results = new Array(resultsLen)\n          for(var i = resultsLen - 1; i >= 0; --i) results[i] = q.poll()\n          results.total = resultsLen + limitedCount\n          resolve(results)\n        }\n\n        isNode?setImmediate(step):step()\n      })\n      p.cancel = function() { canceled = true }\n      return p\n    },\n\n    highlight: function(result, hOpen, hClose) {\n      if(result === null) return null\n      if(hOpen === undefined) hOpen = '<b>'\n      if(hClose === undefined) hClose = '</b>'\n      var highlighted = ''\n      var matchesIndex = 0\n      var opened = false\n      var target = result.target\n      var targetLen = target.length\n      var matchesBest = result.indexes\n      for(var i = 0; i < targetLen; ++i) { var char = target[i]\n        if(matchesBest[matchesIndex] === i) {\n          ++matchesIndex\n          if(!opened) { opened = true\n            highlighted += hOpen\n          }\n\n          if(matchesIndex === matchesBest.length) {\n            highlighted += char + hClose + target.substr(i+1)\n            break\n          }\n        } else {\n          if(opened) { opened = false\n            highlighted += hClose\n          }\n        }\n        highlighted += char\n      }\n\n      return highlighted\n    },\n\n    prepare: function(target) {\n      if(!target) return\n      return {target:target, _targetLowerCodes:fuzzysort.prepareLowerCodes(target), _nextBeginningIndexes:null, score:null, indexes:null, obj:null} // hidden\n    },\n    prepareSlow: function(target) {\n      if(!target) return\n      return {target:target, _targetLowerCodes:fuzzysort.prepareLowerCodes(target), _nextBeginningIndexes:fuzzysort.prepareNextBeginningIndexes(target), score:null, indexes:null, obj:null} // hidden\n    },\n    prepareSearch: function(search) {\n      if(!search) return\n      return fuzzysort.prepareLowerCodes(search)\n    },\n\n\n\n    // Below this point is only internal code\n    // Below this point is only internal code\n    // Below this point is only internal code\n    // Below this point is only internal code\n\n\n\n    getPrepared: function(target) {\n      if(target.length > 999) return fuzzysort.prepare(target) // don't cache huge targets\n      var targetPrepared = preparedCache.get(target)\n      if(targetPrepared !== undefined) return targetPrepared\n      targetPrepared = fuzzysort.prepare(target)\n      preparedCache.set(target, targetPrepared)\n      return targetPrepared\n    },\n    getPreparedSearch: function(search) {\n      if(search.length > 999) return fuzzysort.prepareSearch(search) // don't cache huge searches\n      var searchPrepared = preparedSearchCache.get(search)\n      if(searchPrepared !== undefined) return searchPrepared\n      searchPrepared = fuzzysort.prepareSearch(search)\n      preparedSearchCache.set(search, searchPrepared)\n      return searchPrepared\n    },\n\n    algorithm: function(searchLowerCodes, prepared, searchLowerCode) {\n      var targetLowerCodes = prepared._targetLowerCodes\n      var searchLen = searchLowerCodes.length\n      var targetLen = targetLowerCodes.length\n      var searchI = 0 // where we at\n      var targetI = 0 // where you at\n      var typoSimpleI = 0\n      var matchesSimpleLen = 0\n\n      // very basic fuzzy match; to remove non-matching targets ASAP!\n      // walk through target. find sequential matches.\n      // if all chars aren't found then exit\n      for(;;) {\n        var isMatch = searchLowerCode === targetLowerCodes[targetI]\n        if(isMatch) {\n          matchesSimple[matchesSimpleLen++] = targetI\n          ++searchI; if(searchI === searchLen) break\n          searchLowerCode = searchLowerCodes[typoSimpleI===0?searchI : (typoSimpleI===searchI?searchI+1 : (typoSimpleI===searchI-1?searchI-1 : searchI))]\n        }\n\n        ++targetI; if(targetI >= targetLen) { // Failed to find searchI\n          // Check for typo or exit\n          // we go as far as possible before trying to transpose\n          // then we transpose backwards until we reach the beginning\n          for(;;) {\n            if(searchI <= 1) return null // not allowed to transpose first char\n            if(typoSimpleI === 0) { // we haven't tried to transpose yet\n              --searchI\n              var searchLowerCodeNew = searchLowerCodes[searchI]\n              if(searchLowerCode === searchLowerCodeNew) continue // doesn't make sense to transpose a repeat char\n              typoSimpleI = searchI\n            } else {\n              if(typoSimpleI === 1) return null // reached the end of the line for transposing\n              --typoSimpleI\n              searchI = typoSimpleI\n              searchLowerCode = searchLowerCodes[searchI + 1]\n              var searchLowerCodeNew = searchLowerCodes[searchI]\n              if(searchLowerCode === searchLowerCodeNew) continue // doesn't make sense to transpose a repeat char\n            }\n            matchesSimpleLen = searchI\n            targetI = matchesSimple[matchesSimpleLen - 1] + 1\n            break\n          }\n        }\n      }\n\n      var searchI = 0\n      var typoStrictI = 0\n      var successStrict = false\n      var matchesStrictLen = 0\n\n      var nextBeginningIndexes = prepared._nextBeginningIndexes\n      if(nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target)\n      var firstPossibleI = targetI = matchesSimple[0]===0 ? 0 : nextBeginningIndexes[matchesSimple[0]-1]\n\n      // Our target string successfully matched all characters in sequence!\n      // Let's try a more advanced and strict test to improve the score\n      // only count it as a match if it's consecutive or a beginning character!\n      if(targetI !== targetLen) for(;;) {\n        if(targetI >= targetLen) {\n          // We failed to find a good spot for this search char, go back to the previous search char and force it forward\n          if(searchI <= 0) { // We failed to push chars forward for a better match\n            // transpose, starting from the beginning\n            ++typoStrictI; if(typoStrictI > searchLen-2) break\n            if(searchLowerCodes[typoStrictI] === searchLowerCodes[typoStrictI+1]) continue // doesn't make sense to transpose a repeat char\n            targetI = firstPossibleI\n            continue\n          }\n\n          --searchI\n          var lastMatch = matchesStrict[--matchesStrictLen]\n          targetI = nextBeginningIndexes[lastMatch]\n\n        } else {\n          var isMatch = searchLowerCodes[typoStrictI===0?searchI : (typoStrictI===searchI?searchI+1 : (typoStrictI===searchI-1?searchI-1 : searchI))] === targetLowerCodes[targetI]\n          if(isMatch) {\n            matchesStrict[matchesStrictLen++] = targetI\n            ++searchI; if(searchI === searchLen) { successStrict = true; break }\n            ++targetI\n          } else {\n            targetI = nextBeginningIndexes[targetI]\n          }\n        }\n      }\n\n      { // tally up the score & keep track of matches for highlighting later\n        if(successStrict) { var matchesBest = matchesStrict; var matchesBestLen = matchesStrictLen }\n        else { var matchesBest = matchesSimple; var matchesBestLen = matchesSimpleLen }\n        var score = 0\n        var lastTargetI = -1\n        for(var i = 0; i < searchLen; ++i) { var targetI = matchesBest[i]\n          // score only goes down if they're not consecutive\n          if(lastTargetI !== targetI - 1) score -= targetI\n          lastTargetI = targetI\n        }\n        if(!successStrict) {\n          score *= 1000\n          if(typoSimpleI !== 0) score += -20/*typoPenalty*/\n        } else {\n          if(typoStrictI !== 0) score += -20/*typoPenalty*/\n        }\n        score -= targetLen - searchLen\n        prepared.score = score\n        prepared.indexes = new Array(matchesBestLen); for(var i = matchesBestLen - 1; i >= 0; --i) prepared.indexes[i] = matchesBest[i]\n\n        return prepared\n      }\n    },\n\n    algorithmNoTypo: function(searchLowerCodes, prepared, searchLowerCode) {\n      var targetLowerCodes = prepared._targetLowerCodes\n      var searchLen = searchLowerCodes.length\n      var targetLen = targetLowerCodes.length\n      var searchI = 0 // where we at\n      var targetI = 0 // where you at\n      var matchesSimpleLen = 0\n\n      // very basic fuzzy match; to remove non-matching targets ASAP!\n      // walk through target. find sequential matches.\n      // if all chars aren't found then exit\n      for(;;) {\n        var isMatch = searchLowerCode === targetLowerCodes[targetI]\n        if(isMatch) {\n          matchesSimple[matchesSimpleLen++] = targetI\n          ++searchI; if(searchI === searchLen) break\n          searchLowerCode = searchLowerCodes[searchI]\n        }\n        ++targetI; if(targetI >= targetLen) return null // Failed to find searchI\n      }\n\n      var searchI = 0\n      var successStrict = false\n      var matchesStrictLen = 0\n\n      var nextBeginningIndexes = prepared._nextBeginningIndexes\n      if(nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target)\n      var firstPossibleI = targetI = matchesSimple[0]===0 ? 0 : nextBeginningIndexes[matchesSimple[0]-1]\n\n      // Our target string successfully matched all characters in sequence!\n      // Let's try a more advanced and strict test to improve the score\n      // only count it as a match if it's consecutive or a beginning character!\n      if(targetI !== targetLen) for(;;) {\n        if(targetI >= targetLen) {\n          // We failed to find a good spot for this search char, go back to the previous search char and force it forward\n          if(searchI <= 0) break // We failed to push chars forward for a better match\n\n          --searchI\n          var lastMatch = matchesStrict[--matchesStrictLen]\n          targetI = nextBeginningIndexes[lastMatch]\n\n        } else {\n          var isMatch = searchLowerCodes[searchI] === targetLowerCodes[targetI]\n          if(isMatch) {\n            matchesStrict[matchesStrictLen++] = targetI\n            ++searchI; if(searchI === searchLen) { successStrict = true; break }\n            ++targetI\n          } else {\n            targetI = nextBeginningIndexes[targetI]\n          }\n        }\n      }\n\n      { // tally up the score & keep track of matches for highlighting later\n        if(successStrict) { var matchesBest = matchesStrict; var matchesBestLen = matchesStrictLen }\n        else { var matchesBest = matchesSimple; var matchesBestLen = matchesSimpleLen }\n        var score = 0\n        var lastTargetI = -1\n        for(var i = 0; i < searchLen; ++i) { var targetI = matchesBest[i]\n          // score only goes down if they're not consecutive\n          if(lastTargetI !== targetI - 1) score -= targetI\n          lastTargetI = targetI\n        }\n        if(!successStrict) score *= 1000\n        score -= targetLen - searchLen\n        prepared.score = score\n        prepared.indexes = new Array(matchesBestLen); for(var i = matchesBestLen - 1; i >= 0; --i) prepared.indexes[i] = matchesBest[i]\n\n        return prepared\n      }\n    },\n\n    prepareLowerCodes: function(str) {\n      var strLen = str.length\n      var lowerCodes = [] // new Array(strLen)    sparse array is too slow\n      var lower = str.toLowerCase()\n      for(var i = 0; i < strLen; ++i) lowerCodes[i] = lower.charCodeAt(i)\n      return lowerCodes\n    },\n    prepareBeginningIndexes: function(target) {\n      var targetLen = target.length\n      var beginningIndexes = []; var beginningIndexesLen = 0\n      var wasUpper = false\n      var wasAlphanum = false\n      for(var i = 0; i < targetLen; ++i) {\n        var targetCode = target.charCodeAt(i)\n        var isUpper = targetCode>=65&&targetCode<=90\n        var isAlphanum = isUpper || targetCode>=97&&targetCode<=122 || targetCode>=48&&targetCode<=57\n        var isBeginning = isUpper && !wasUpper || !wasAlphanum || !isAlphanum\n        wasUpper = isUpper\n        wasAlphanum = isAlphanum\n        if(isBeginning) beginningIndexes[beginningIndexesLen++] = i\n      }\n      return beginningIndexes\n    },\n    prepareNextBeginningIndexes: function(target) {\n      var targetLen = target.length\n      var beginningIndexes = fuzzysort.prepareBeginningIndexes(target)\n      var nextBeginningIndexes = [] // new Array(targetLen)     sparse array is too slow\n      var lastIsBeginning = beginningIndexes[0]\n      var lastIsBeginningI = 0\n      for(var i = 0; i < targetLen; ++i) {\n        if(lastIsBeginning > i) {\n          nextBeginningIndexes[i] = lastIsBeginning\n        } else {\n          lastIsBeginning = beginningIndexes[++lastIsBeginningI]\n          nextBeginningIndexes[i] = lastIsBeginning===undefined ? targetLen : lastIsBeginning\n        }\n      }\n      return nextBeginningIndexes\n    },\n\n    cleanup: cleanup,\n    new: fuzzysortNew,\n  }\n  return fuzzysort\n} // fuzzysortNew\n\n// This stuff is outside fuzzysortNew, because it's shared with instances of fuzzysort.new()\nvar isNode = typeof require !== 'undefined' && typeof window === 'undefined'\n// var MAX_INT = Number.MAX_SAFE_INTEGER\n// var MIN_INT = Number.MIN_VALUE\nvar preparedCache = new Map()\nvar preparedSearchCache = new Map()\nvar noResults = []; noResults.total = 0\nvar matchesSimple = []; var matchesStrict = []\nfunction cleanup() { preparedCache.clear(); preparedSearchCache.clear(); matchesSimple = []; matchesStrict = [] }\nfunction defaultScoreFn(a) {\n  var max = -9007199254740991\n  for (var i = a.length - 1; i >= 0; --i) {\n    var result = a[i]; if(result === null) continue\n    var score = result.score\n    if(score > max) max = score\n  }\n  if(max === -9007199254740991) return null\n  return max\n}\n\n// prop = 'key'              2.5ms optimized for this case, seems to be about as fast as direct obj[prop]\n// prop = 'key1.key2'        10ms\n// prop = ['key1', 'key2']   27ms\nfunction getValue(obj, prop) {\n  var tmp = obj[prop]; if(tmp !== undefined) return tmp\n  var segs = prop\n  if(!Array.isArray(prop)) segs = prop.split('.')\n  var len = segs.length\n  var i = -1\n  while (obj && (++i < len)) obj = obj[segs[i]]\n  return obj\n}\n\nfunction isObj(x) { return typeof x === 'object' } // faster as a function\n\n// Hacked version of https://github.com/lemire/FastPriorityQueue.js\nvar fastpriorityqueue=function(){var r=[],o=0,e={};function n(){for(var e=0,n=r[e],c=1;c<o;){var f=c+1;e=c,f<o&&r[f].score<r[c].score&&(e=f),r[e-1>>1]=r[e],c=1+(e<<1)}for(var a=e-1>>1;e>0&&n.score<r[a].score;a=(e=a)-1>>1)r[e]=r[a];r[e]=n}return e.add=function(e){var n=o;r[o++]=e;for(var c=n-1>>1;n>0&&e.score<r[c].score;c=(n=c)-1>>1)r[n]=r[c];r[n]=e},e.poll=function(){if(0!==o){var e=r[0];return r[0]=r[--o],n(),e}},e.peek=function(e){if(0!==o)return r[0]},e.replaceTop=function(o){r[0]=o,n()},e};\nvar q = fastpriorityqueue() // reuse this, except for async, it needs to make its own\n\nreturn fuzzysortNew()\n}) // UMD\n\n// TODO: (performance) wasm version!?\n\n// TODO: (performance) layout memory in an optimal way to go fast by avoiding cache misses\n\n// TODO: (performance) preparedCache is a memory leak\n\n// TODO: (like sublime) backslash === forwardslash\n\n// TODO: (performance) i have no idea how well optizmied the allowing typos algorithm is\n"],"sourceRoot":"/source/"}